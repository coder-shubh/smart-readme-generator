import os
import json
import re
import shutil
import tempfile
import subprocess
import argparse
from pathlib import Path


def load_json(path):
    try:
        return json.loads(Path(path).read_text())
    except Exception:
        return {}


def detect_stack_and_dependencies(project_path: Path):
    tech = set()
    deps = {}

    pkg = project_path / "package.json"
    if pkg.exists():
        tech.add("Node.js")
        data = load_json(pkg)
        deps = data.get("dependencies", {})
        if "react-native" in deps:
            tech.add("React Native")
        elif "react" in deps:
            tech.add("React")
        if "express" in deps:
            tech.add("Express.js")

    if (project_path / "requirements.txt").exists() or list(project_path.glob("*.py")):
        tech.add("Python")
        txt = project_path / "requirements.txt"
        if txt.exists():
            deps = {r.split("==")[0]: r.split("==")[-1] for r in txt.read_text().splitlines() if r and "==" in r}

    if (project_path / "Dockerfile").exists():
        tech.add("Docker")
    if (project_path / "pom.xml").exists():
        tech.add("Java (Maven)")
    if (project_path / "Makefile").exists():
        tech.add("Make")

    return list(tech), deps


def detect_run_commands(project_path: Path):
    cmds = []
    pkg = project_path / "package.json"
    if pkg.exists():
        data = load_json(pkg)
        for name, cmd in data.get("scripts", {}).items():
            cmds.append((name, cmd))
    mk = project_path / "Makefile"
    if mk.exists():
        for line in mk.read_text().splitlines():
            m = re.match(r'^([a-zA-Z0-9_-]+):', line)
            if m:
                cmds.append((m.group(1), f"make {m.group(1)}"))
    for py in project_path.glob("*.py"):
        if "__main__" in py.read_text():
            cmds.append(("run-script", f"python {py.name}"))
    return cmds


def find_license_file(project_path: Path):
    for fname in ["LICENSE", "LICENSE.md", "LICENSE.txt"]:
        if (project_path / fname).exists():
            return fname
    return None


def scan_structure(project_path: Path):
    dirs, files = [], []
    for root, ds, fs in os.walk(project_path):
        ds[:] = [d for d in ds if not d.startswith('.')]
        rel = os.path.relpath(root, project_path)
        for d in ds:
            if d not in ["node_modules", "__pycache__"]:
                dirs.append(os.path.join(rel, d))
        for f in fs:
            if f.endswith(('.js', '.jsx', '.ts', '.tsx', '.py')):
                path = os.path.join(rel, f)
                if "test" not in path.lower() and "node_modules" not in path:
                    files.append(path)
    return sorted(set(dirs)), sorted(set(files))


def generate_readme(project_path: Path):
    name = project_path.name
    tech, deps = detect_stack_and_dependencies(project_path)
    cmds = detect_run_commands(project_path)
    lic = find_license_file(project_path)
    dirs, files = scan_structure(project_path)
    desc = ""
    pkg = project_path / "package.json"
    if pkg.exists():
        desc = load_json(pkg).get("description", "")

    lines = [f"# {name}\n"]
    if desc:
        lines.append(f"{desc}\n\n")
    lines.append("_Auto-generated by Smart README Generator_\n\n")
    lines.append("## üîç Tech Stack\n")
    lines += [f"- {t}\n" for t in tech] if tech else ["- Unknown\n"]
    if deps:
        lines.append("\n## üì¶ Dependencies\n")
        for d, v in list(deps.items())[:10]:
            lines.append(f"- **{d}**: {v}\n")
    if cmds:
        lines.append("\n## üöÄ Run Commands\n")
        for n, c in cmds:
            lines.append(f"- **{n}**: `{c}`\n")
    lines.append("\n## üìÅ Project Structure\n")
    if dirs:
        lines.append("### Directories\n")
        lines += [f"- `{d}`\n" for d in dirs[:10]]
    if files:
        lines.append("\n### Key Files\n")
        lines += [f"- `{f}`\n" for f in files[:10]]
    lines.append("\n## üß™ Testing\n")
    if any(f.lower().startswith("test") or "pytest" in ''.join(files) for f in files):
        lines.append("Tests seem to be present‚Äîrun via pytest or your test tool.\n")
    else:
        lines.append("No tests detected.\n")
    lines.append("\n## üìù License\n")
    lines.append(f"- {lic}" if lic else "- No license file detected.\n")
    return "".join(lines)


def clone_repo(git_url: str, tmpdir: Path):
    try:
        subprocess.run(
            ["git", "clone", git_url],
            cwd=tmpdir,
            check=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
        # Get repo folder name from the URL
        repo_name = git_url.rstrip("/").split("/")[-1].replace(".git", "")
        project_path = tmpdir / repo_name
        return project_path if project_path.exists() else None
    except Exception as e:
        print(f"‚ùå Failed to clone repo: {e}")
        return None



def main():
    p = argparse.ArgumentParser("Smart README Generator")
    p.add_argument("path", nargs="?", default=".", help="Project folder path or Git repo URL")
    p.add_argument("-o", "--output", default="README_GENERATED.md", help="Output filename")
    args = p.parse_args()

    input_path = args.path
    is_git_url = (input_path.startswith("http://") or input_path.startswith("https://")) and input_path.endswith(".git")

    if is_git_url:
        if shutil.which("git") is None:
            print("‚ùå 'git' is not installed or not in PATH.")
            return
        with tempfile.TemporaryDirectory() as tmpdirname:
            tmp_path = Path(tmpdirname)
            print(f"üì• Cloning from {input_path} ...")
            project_path = clone_repo(input_path, tmp_path)
            if not project_path:
                return
            md = generate_readme(project_path)
    else:
        project_path = Path(input_path).resolve()
        if not project_path.is_dir():
            print("‚ùå Invalid folder path.")
            return
        md = generate_readme(project_path)
    print(md)


    # output_path = project_path / args.output
    # output_path.parent.mkdir(parents=True, exist_ok=True)
    # with open(output_path, "w") as f:
    #     f.write(md)
    #
    # print(f"‚úÖ Generated {args.output} in {project_path}")


if __name__ == "__main__":
    main()
